//
//  NSObject+ESAutoCoding.h
//  ESFramework
//
//  Created by Elf Sundae on 15/8/22.
//  Copyright (c) 2015å¹´ www.0x123.com. All rights reserved.
//

#import "ESDefines.h"

/* NSCoding implementation */
#define ES_CODING_IMPLEMENTATION \
    - (instancetype)initWithCoder:(NSCoder *)aDecoder \
    { \
        return [self initWithCoder_es:aDecoder]; \
    } \
    - (void)encodeWithCoder:(NSCoder *)aCoder \
    { \
        [self es_encodeWithCoder:aCoder]; \
    }

/* NSSecureCoding implementation */
#define ES_SECURECODING_IMPLEMENTATION \
    ES_CODING_IMPLEMENTATION \
    + (BOOL)supportsSecureCoding \
    { \
        return YES; \
    }

#define ES_COPYING_IMPLEMENTATION \
    - (id)copyWithZone:(NSZone *)zone \
    { \
        return [self es_copyWithZone:zone]; \
    }

/*!
 * The ESAutoCoding category for NSObject makes it easier for your models or other objects to
 * support NSCoding or NSCopying.
 *
 * ESAutoCoding is inspired by [nicklockwood/AutoCoding](https://github.com/nicklockwood/AutoCoding)
 *
 * ### Supported Property Types
 * These types below will be automatically encoded.
 *
 * + `id`
 * + basic number types like `char` `int` `long` `float` `double` `unsigned long long`, etc.
 * + `NSValue`
 * + `struct`, like `CGRect` `CGSize` `CGAffineTransform`, etc.
 *
 * ### Descussion
 * 1. To exclude certain properties of your object from being encoded,
 * you can do so in any of the following ways:
 *      - Only use an ivar, without declaring a matching `@property`.
 *      - Change the name of the ivar to something which is not KVC compliant.
 *              (not the same as the property name, nor the property name with an `_` prefix either,
 *              or `@synthesize` the ivar an another name, `@synthesize name = __name`
 *              (here ivar with two `_` prefix))
 *      - Override the `+es_codableProperties` method
 * 2. You can add additional coding/decoding logic by overriding the `-modelSetWithCoder:` and/or
 * the `-encodeWithCoder:` methods. As long as you call the `[super ...]` implementation,
 * the auto-coding will still function.
 *
 */
@interface NSObject (ESAutoCoding)

/// NSCoding Delegate
- (instancetype)initWithCoder_es:(NSCoder *)aDecoder;
/// NSCoding Delegate
- (void)es_encodeWithCoder:(NSCoder *)aCoder;

/**
 * Populates the object's properties using the provided `NSCoder` object, based
 * on the `codableProperties` dictionary. This is called internally by the
 * `initWithCoder:` method, but may be useful if you wish to initialise an object
 * from a coded archive after it has already been created. You could even
 * initialise the object by merging the results of several different archives by
 * calling `setWithCoder:` more than once.
 */
- (void)es_setWithCoder:(NSCoder *)aDecoder;

/// NSCopying Delegate
- (id)es_copyWithZone:(NSZone *)zone;

/**
 * Returns a dictionary containing the names and classes of all the properties of
 * the class that will be automatically saved, loaded and copied when the object
 * is archived using `NSKeyedArchiver/Unarchiver`. The values of the dictionary
 * represent the class used to encode each property (e.g. `NSString` for strings,
 * `NSNumber` for numeric values or booleans, `NSValue` for structs, etc).
 *
 * This dictionary is automatically generated by scanning the properties defined
 * in the class definition at runtime. Read-only and private properties will also
 * be coded as long as they have KVC-compliant ivar names (i.e. the ivar matches
 * the property name, or is the same but with a _ prefix). Any properties that
 * are not backed by an ivar, or whose ivar name does not match the property name
 * will not be encoded (this is a design feature, not a limitation - it makes it
 * easier to exclude properties from encoding)
 *
 * It is not normally necessary to override this method unless you wish to add
 * ivars for coding that do not have matching property definitions, or if you
 * wish to code virtual properties (properties or setter/getter method pairs that
 * are not backed by an ivar). If you wish to exclude certain properties from the
 * serialisation process, you can deliberately give them an non KVC-compliant
 * ivar name (see above).
 *
 * Note that this method only returns the properties defined on a particular
 * class and not any properties that are inherited from its superclasses. You
 * *do not* need to call `[super es_codableProperties]` if you override this method.
 */
+ (NSDictionary<NSString *, Class> *)es_codableProperties;

/**
 * Returns all the codable properties of the object, including those that are
 * inherited from superclasses. You should not override this method - if you
 * want to add additional properties, override the `+es_codableProperties` class
 * method instead.
 */
- (NSDictionary<NSString *, Class> *)es_codableProperties;

/**
 * Returns a dictionary of the values of all the codable properties of the
 * object. It is equivalent to calling `dictionaryWithValuesForKeys:` with the
 * result of `object.es_codableProperties.allKeys` as the parameter.
 */
- (NSDictionary<NSString *, id> *)es_dictionaryRepresentation;

/**
 * Returns a string that represents the contents of the receiving class.
 */
- (NSString *)es_description;

/**
 * Attempts to load the file using the following sequence: 1) If the file is an
 * NSCoded archive, load the root object and return it; 2) If the file is an
 * ordinary Plist, load and return the root object; 3) Return the raw data as an
 * `NSData` object. If the de-serialised object is not a subclass of the class
 * being used to load it, an exception will be thrown (to avoid this, call the
 * method on `NSObject` instead of a specific subclass).
 */
+ (instancetype)es_objectWithContentsOfFile:(NSString *)filePath;

/**
 * Attempts to write the file to disk. This method is overridden by the
 * equivalent methods for `NSData`, `NSDictionary` and `NSArray`, which save the
 * file as a human-readable XML Plist rather than a binary NSCoded Plist archive,
 * but the `objectWithContentsOfFile:` method will correctly de-serialise these
 * again anyway. For any other object it will serialise the object using the
 * `NSCoding` protocol and write out the file as a NSCoded binary Plist archive.
 * Returns `YES` on success and `NO` on failure.
 */
- (BOOL)es_writeToFile:(NSString *)filePath atomically:(BOOL)useAuxiliaryFile;

@end
